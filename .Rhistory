}
ddist <- function(x, y) {
2 * c(x - y, y - x)
}
df <- expand_grid(x=seq(0, 1, length.out=20),
y=seq(0, 1, length.out=20)) %>%
rowwise() %>%
mutate(dist = mydist(x, y)) %>%
rowwise() %>%
# mutate(ddist = ddist(x, y)) %>%
# rowwise() %>%
mutate(ddistx = ddist(x, y)[1]) %>%
rowwise() %>%
mutate(ddisty = ddist(x, y)[2])
rowid <- c(19, 49, 149, 169, 249, 349, 389)
grad_plot <- df[rowid, ]
ggplot(df) +
geom_contour_filled(aes(x = x, y = y, z = dist)) +
geom_point(data = grad_plot, aes(x, y)) +
geom_segment(data=grad_plot, aes(x = x, y = y, xend = x - ddistx, yend = y - ddisty),
arrow = arrow(length = unit(0.1, "in")))
library(Matrix)
library(igraph)
library(tidyverse)
library(BayesMRA)
library(patchwork)
source("~/sgMRA/R/eval_basis.R")
source("~/sgMRA/R/dwendland_basis.R")
M <- 1
n_coarse_grid <- 40
grid <- make_grid(M = M, n_coarse_grid = n_coarse_grid)
N <- 100^2
locs <- expand_grid(x=seq(0, 1, length.out=sqrt(N)),
y=seq(0, 1, length.out=sqrt(N)))
MRA1 <- eval_basis(locs, grid)
W1 <- MRA1$W
Q1 <- make_Q_alpha_2d(sqrt(MRA1$n_dims), phi=0.9)
class(Q1) <- "spam"
alpha_x1 <- drop(rmvnorm.prec.const(1, mu = rep(0, nrow(Q1)), Q = Q1, A=rep(1, nrow(W1)) %*% W1, a=0))
alpha_y1 <- drop(rmvnorm.prec.const(1, mu = rep(0, nrow(Q1)), Q = Q1, A=rep(1, nrow(W1)) %*% W1, a=0))
# Deep BayesMRA
library(spam)
library(Matrix)
library(igraph)
library(tidyverse)
library(BayesMRA)
library(patchwork)
source("~/sgMRA/R/eval_basis.R")
source("~/sgMRA/R/dwendland_basis.R")
M <- 1
n_coarse_grid <- 40
grid <- make_grid(M = M, n_coarse_grid = n_coarse_grid)
N <- 100^2
# Deep BayesMRA
library(spam)
library(Matrix)
library(igraph)
library(tidyverse)
library(BayesMRA)
library(patchwork)
source("~/sgMRA/R/eval_basis.R")
source("~/sgMRA/R/dwendland_basis.R")
M <- 1
n_coarse_grid <- 40
grid <- make_grid(M = M, n_coarse_grid = n_coarse_grid)
grid <- make_grid(locs, M = M, n_coarse_grid = n_coarse_grid)
N <- 100^2
locs <- expand_grid(x=seq(0, 1, length.out=sqrt(N)),
y=seq(0, 1, length.out=sqrt(N)))
grid <- make_grid(locs, M = M, n_coarse_grid = n_coarse_grid)
MRA1 <- eval_basis(locs, grid)
W1 <- MRA1$W
Q1 <- make_Q_alpha_2d(sqrt(MRA1$n_dims), phi=0.9)
class(Q1) <- "spam"
alpha_x1 <- drop(rmvnorm.prec.const(1, mu = rep(0, nrow(Q1)), Q = Q1, A=rep(1, nrow(W1)) %*% W1, a=0))
alpha_y1 <- drop(rmvnorm.prec.const(1, mu = rep(0, nrow(Q1)), Q = Q1, A=rep(1, nrow(W1)) %*% W1, a=0))
# calculate the chain rule derivative of the distance matrix
str(MRA1$D)
diffs <- 2*(locs[MRA1$D$ind[, 1], ] - grid$locs_grid[[1]][MRA1$D$ind[, 2], ])
MRA1$D$diffsx <- diffs$x
Wdiffsx <- spam(MRA1$D[c("ind", "diffsx")], nrow = MRA1$D$da[1], ncol = MRA1$D$da[2])
MRA1$D$diffsy <- diffs$y
Wdiffsy <- spam(MRA1$D[c("ind", "diffsy")], nrow = MRA1$D$da[1], ncol = MRA1$D$da[2])
grad_alpha_x1 <- (MRA1$dW[[1]] * Wdiffsx * MRA1$W) %*% alpha_x1
grad_alpha_y1 <- (MRA1$dW[[1]] * Wdiffsy * MRA1$W) %*% alpha_y1
str(MRA1$dW)
grad_alpha_x1 <- (MRA1$dW * Wdiffsx * MRA1$W) %*% alpha_x1
grad_alpha_y1 <- (MRA1$dW * Wdiffsy * MRA1$W) %*% alpha_y1
dat <- tibble(d = seq(0, 2, length.out=100),
f = wendland_basis(d, radius = 2),
df = dwendland_basis(d, radius = 2))
ggplot(dat) +
geom_line(aes(x = d, y = f), color='red') +
geom_line(aes(x = d, y = df), color='blue')
mydist <- function(x, y) {
n <- length(x)
out <- rep(0, n)
for (i in 1:n) {
out[i] <- sqrt(sum((x[i] - y[i])^2))
}
out
}
ddistx <- function(x, y) {
2 * (x - y)
}
ddisty <- function(x, y) {
2 * (y - x)
}
ddist <- function(x, y) {
2 * c(x - y, y - x)
}
df <- expand_grid(x=seq(0, 1, length.out=20),
y=seq(0, 1, length.out=20)) %>%
rowwise() %>%
mutate(dist = mydist(x, y)) %>%
rowwise() %>%
# mutate(ddist = ddist(x, y)) %>%
# rowwise() %>%
mutate(ddistx = ddist(x, y)[1]) %>%
rowwise() %>%
mutate(ddisty = ddist(x, y)[2])
rowid <- c(19, 49, 149, 169, 249, 349, 389)
grad_plot <- df[rowid, ]
ggplot(df) +
geom_contour_filled(aes(x = x, y = y, z = dist)) +
geom_point(data = grad_plot, aes(x, y)) +
geom_segment(data=grad_plot, aes(x = x, y = y, xend = x - ddistx, yend = y - ddisty),
arrow = arrow(length = unit(0.1, "in")))
source("~/sgMRA/R/eval_basis.R")
n_iter = 200
# add in Adam optimization schedule
out <- fit_sgd(y=dat_sim$y,
locs=dat_sim$locs,
grid=dat_sim$grid,
# alpha=alpha,
alpha=NULL,
alpha_x1=NULL,
# alpha_x1=NULL,
alpha_y1=NULL,
# alpha_y1=NULL,
alpha_x2=NULL,
alpha_y2=NULL,
learn_rate = 0.001,
n_iter = n_iter,
n_message = 1)
# TODO
# - work on fitting these using stochastic gradient descent or elliptical slice sampling
# Deep BayesMRA
library(spam)
library(Matrix)
library(igraph)
library(tidyverse)
library(BayesMRA)
library(patchwork)
source("~/sgMRA/R/eval_basis.R")
source("~/sgMRA/R/dwendland_basis.R")
set.seed(44)
N <- 2^12
M <- 1
n_coarse_grid <- 80
source("~/sgMRA/R/sim-deep-mra.R")
dat_sim <- sim_deep_mra(N, M, n_coarse_grid, n_layers = 3, sigma = 0.01)
str(dat_sim)
length(dat_sim$MRA)
str(dat_sim$alpha)
str(dat_sim$alpha_x)
locs <- dat_sim$locs
z <- dat_sim$z
y_obs<- dat_sim$y
dat <- data.frame(x = locs$x, y = locs$y, z = z, y_obs = y_obs)
p1 <- ggplot(dat, aes(x = x, y = y, fill = z)) +
geom_raster() +
scale_fill_viridis_c()
p2 <- ggplot(dat, aes(x = x, y = y, fill = y_obs)) +
geom_raster() +
scale_fill_viridis_c()
p1 + p2
# make this into a function
dat <- data.frame(x = locs$x, y = locs$y,
layer = rep(c(1, 1, 2, 2, 3), each=N),
# layer = rep(c(1, 1, 2), each=N),
# group = rep(c("x", "y", "z"), each = N),
group = rep(c("x", "y", "x", "y", "z"), each = N),
z = c(dat_sim$MRA[[3]]$W %*% dat_sim$alpha_x[[2]], dat_sim$MRA[[3]]$W %*% dat_sim$alpha_y[[2]],
dat_sim$MRA[[2]]$W %*% dat_sim$alpha_x[[1]], dat_sim$MRA[[2]]$W %*% dat_sim$alpha_y[[1]],
dat_sim$MRA[[1]]$W %*% dat_sim$alpha))
p_layers_sim <- ggplot(dat, aes(x, y, fill=z)) +
geom_raster() +
scale_fill_viridis_c() +
facet_grid(layer ~ group) +
ggtitle("simulated layers")
p_layers_sim
# Fit the model using sgd ----
source("~/sgMRA/scripts/fit-deep-MRA-sgd.R")
source("~/sgMRA/R/adam.R")
n_iter = 200
# add in Adam optimization schedule
out <- fit_sgd(y=dat_sim$y,
locs=dat_sim$locs,
grid=dat_sim$grid,
# alpha=alpha,
alpha=NULL,
alpha_x1=NULL,
# alpha_x1=NULL,
alpha_y1=NULL,
# alpha_y1=NULL,
alpha_x2=NULL,
alpha_y2=NULL,
learn_rate = 0.001,
n_iter = n_iter,
n_message = 1)
plot(out$loss, type = 'l')
# examine the fitted layers
dat <- data.frame(x = locs$x, y = locs$y,
layer = rep(c(1, 1, 2, 2, 3), each=N),
group = rep(c("x", "y", "x", "y", "z"), each = N),
z = c(out$MRA1$W %*% out$alpha_x1, out$MRA1$W %*% out$alpha_y1,
out$MRA2$W %*% out$alpha_x2, out$MRA2$W %*% out$alpha_y2,
out$MRA$W %*% out$alpha))
p_layers_fit <- ggplot(dat, aes(x, y, fill=z)) +
geom_raster() +
scale_fill_viridis_c() +
facet_grid(layer ~ group) +
ggtitle("fitted layers")
p_layers_sim / p_layers_fit
dat <- data.frame(x = locs$x, y = locs$y,
z = z,
z_fit = out$MRA$W %*% out$alpha)
p_fit <- ggplot(dat, aes(x = x, y = y, fill = z_fit)) +
geom_raster() +
scale_fill_viridis_c()
p1 / p_fit
dat <- data.frame(z = dat_sim$z,
z_fit = out$MRA$W %*% out$alpha)
p5 <- ggplot(dat, aes(x = z, y = z_fit)) +
geom_point() +
stat_smooth(method = 'lm')
p5
cor(dat$z, dat$z_fit)
source("~/sgMRA/R/eval_basis.R")
# add in Adam optimization schedule
out <- fit_sgd(y=dat_sim$y,
locs=dat_sim$locs,
grid=dat_sim$grid,
# alpha=alpha,
alpha=NULL,
alpha_x1=NULL,
# alpha_x1=NULL,
alpha_y1=NULL,
# alpha_y1=NULL,
alpha_x2=NULL,
alpha_y2=NULL,
learn_rate = 0.01,
n_iter = n_iter,
n_message = 1)
plot(out$loss, type = 'l')
# examine the fitted layers
dat <- data.frame(x = locs$x, y = locs$y,
layer = rep(c(1, 1, 2, 2, 3), each=N),
group = rep(c("x", "y", "x", "y", "z"), each = N),
z = c(out$MRA1$W %*% out$alpha_x1, out$MRA1$W %*% out$alpha_y1,
out$MRA2$W %*% out$alpha_x2, out$MRA2$W %*% out$alpha_y2,
out$MRA$W %*% out$alpha))
p_layers_fit <- ggplot(dat, aes(x, y, fill=z)) +
geom_raster() +
scale_fill_viridis_c() +
facet_grid(layer ~ group) +
ggtitle("fitted layers")
p_layers_sim / p_layers_fit
dat <- data.frame(x = locs$x, y = locs$y,
z = z,
z_fit = out$MRA$W %*% out$alpha)
p_fit <- ggplot(dat, aes(x = x, y = y, fill = z_fit)) +
geom_raster() +
scale_fill_viridis_c()
p1 / p_fit
dat <- data.frame(z = dat_sim$z,
z_fit = out$MRA$W %*% out$alpha)
p5 <- ggplot(dat, aes(x = z, y = z_fit)) +
geom_point() +
stat_smooth(method = 'lm')
p5
cor(dat$z, dat$z_fit)
# examine the fitted layers
dat <- data.frame(x = locs$x, y = locs$y,
layer = rep(c(1, 1, 2, 2, 3), each=N),
group = rep(c("x", "y", "x", "y", "z"), each = N),
z = c(out$MRA2$W %*% out$alpha_x2, out$MRA2$W %*% out$alpha_y2,
out$MRA1$W %*% out$alpha_x1, out$MRA1$W %*% out$alpha_y1,
out$MRA$W %*% out$alpha))
p_layers_fit <- ggplot(dat, aes(x, y, fill=z)) +
geom_raster() +
scale_fill_viridis_c() +
facet_grid(layer ~ group) +
ggtitle("fitted layers")
p_layers_sim / p_layers_fit
dat <- data.frame(x = locs$x, y = locs$y,
z = z,
z_fit = out$MRA$W %*% out$alpha)
p_fit <- ggplot(dat, aes(x = x, y = y, fill = z_fit)) +
geom_raster() +
scale_fill_viridis_c()
p1 / p_fit
dat <- data.frame(z = dat_sim$z,
z_fit = out$MRA$W %*% out$alpha)
p5 <- ggplot(dat, aes(x = z, y = z_fit)) +
geom_point() +
stat_smooth(method = 'lm')
p5
cor(dat$z, dat$z_fit)
ddist <- function(x, y) {
2 * c(x - y, x-y)
}
df <- expand_grid(x=seq(0, 1, length.out=20),
y=seq(0, 1, length.out=20)) %>%
rowwise() %>%
mutate(dist = mydist(x, y)) %>%
# rowwise() %>%
# mutate(ddist = ddist(x, y)) %>%
rowwise() %>%
mutate(ddistx = ddist(x, y)[1]) %>%
rowwise() %>%
mutate(ddisty = ddist(x, y)[2])
rowid <- c(19, 49, 149, 169, 249, 349, 389)
grad_plot <- df[rowid, ]
ggplot(df) +
geom_contour_filled(aes(x = x, y = y, z = dist)) +
geom_point(data = grad_plot, aes(x, y)) +
geom_segment(data=grad_plot, aes(x = x, y = y, xend = x - ddistx, yend = y - ddisty),
arrow = arrow(length = unit(0.1, "in")))
# Deep BayesMRA
library(spam)
library(Matrix)
library(igraph)
library(tidyverse)
library(BayesMRA)
library(patchwork)
source("~/sgMRA/R/eval_basis.R")
source("~/sgMRA/R/dwendland_basis.R")
M <- 1
n_coarse_grid <- 40
N <- 100^2
locs <- expand_grid(x=seq(0, 1, length.out=sqrt(N)),
y=seq(0, 1, length.out=sqrt(N)))
grid <- make_grid(locs, M = M, n_coarse_grid = n_coarse_grid)
MRA1 <- eval_basis(locs, grid)
W1 <- MRA1$W
Q1 <- make_Q_alpha_2d(sqrt(MRA1$n_dims), phi=0.9)
class(Q1) <- "spam"
alpha_x1 <- drop(rmvnorm.prec.const(1, mu = rep(0, nrow(Q1)), Q = Q1, A=rep(1, nrow(W1)) %*% W1, a=0))
alpha_y1 <- drop(rmvnorm.prec.const(1, mu = rep(0, nrow(Q1)), Q = Q1, A=rep(1, nrow(W1)) %*% W1, a=0))
# calculate the chain rule derivative of the distance matrix
str(MRA1$D)
diffs <- 2*(locs[MRA1$D$ind[, 1], ] - grid$locs_grid[[1]][MRA1$D$ind[, 2], ])
MRA1$D$diffsx <- diffs$x
Wdiffsx <- spam(MRA1$D[c("ind", "diffsx")], nrow = MRA1$D$da[1], ncol = MRA1$D$da[2])
MRA1$D$diffsy <- diffs$y
Wdiffsy <- spam(MRA1$D[c("ind", "diffsy")], nrow = MRA1$D$da[1], ncol = MRA1$D$da[2])
grad_alpha_x1 <- (MRA1$dW * Wdiffsx * MRA1$W) %*% alpha_x1
grad_alpha_y1 <- (MRA1$dW * Wdiffsy * MRA1$W) %*% alpha_y1
dat <- tibble(d = seq(0, 2, length.out=100),
f = wendland_basis(d, radius = 2),
df = dwendland_basis(d, radius = 2))
ggplot(dat) +
geom_line(aes(x = d, y = f), color='red') +
geom_line(aes(x = d, y = df), color='blue')
mydist <- function(x, y) {
n <- length(x)
out <- rep(0, n)
for (i in 1:n) {
out[i] <- sqrt(sum((x[i] - y[i])^2))
}
out
}
ddistx <- function(x, y) {
2 * (x - y)
}
ddisty <- function(x, y) {
2 * (y - x)
}
ddist <- function(x, y) {
2 * c(x - y, x-y)
}
df <- expand_grid(x=seq(0, 1, length.out=20),
y=seq(0, 1, length.out=20)) %>%
rowwise() %>%
mutate(dist = mydist(x, y)) %>%
# rowwise() %>%
# mutate(ddist = ddist(x, y)) %>%
rowwise() %>%
mutate(ddistx = ddist(x, y)[1]) %>%
rowwise() %>%
mutate(ddisty = ddist(x, y)[2])
rowid <- c(19, 49, 149, 169, 249, 349, 389)
grad_plot <- df[rowid, ]
ggplot(df) +
geom_contour_filled(aes(x = x, y = y, z = dist)) +
geom_point(data = grad_plot, aes(x, y)) +
geom_segment(data=grad_plot, aes(x = x, y = y, xend = x - ddistx, yend = y - ddisty),
arrow = arrow(length = unit(0.1, "in")))
# Deep BayesMRA
library(spam)
library(Matrix)
library(igraph)
library(tidyverse)
library(BayesMRA)
library(patchwork)
source("~/sgMRA/R/eval_basis.R")
source("~/sgMRA/R/dwendland_basis.R")
M <- 1
n_coarse_grid <- 40
N <- 100^2
locs <- expand_grid(x=seq(0, 1, length.out=sqrt(N)),
y=seq(0, 1, length.out=sqrt(N)))
grid <- make_grid(locs, M = M, n_coarse_grid = n_coarse_grid)
MRA1 <- eval_basis(locs, grid)
W1 <- MRA1$W
Q1 <- make_Q_alpha_2d(sqrt(MRA1$n_dims), phi=0.9)
class(Q1) <- "spam"
alpha_x1 <- drop(rmvnorm.prec.const(1, mu = rep(0, nrow(Q1)), Q = Q1, A=rep(1, nrow(W1)) %*% W1, a=0))
alpha_y1 <- drop(rmvnorm.prec.const(1, mu = rep(0, nrow(Q1)), Q = Q1, A=rep(1, nrow(W1)) %*% W1, a=0))
# calculate the chain rule derivative of the distance matrix
str(MRA1$D)
diffs <- 2*(locs[MRA1$D$ind[, 1], ] - grid$locs_grid[[1]][MRA1$D$ind[, 2], ])
MRA1$D$diffsx <- diffs$x
Wdiffsx <- spam(MRA1$D[c("ind", "diffsx")], nrow = MRA1$D$da[1], ncol = MRA1$D$da[2])
MRA1$D$diffsy <- diffs$y
Wdiffsy <- spam(MRA1$D[c("ind", "diffsy")], nrow = MRA1$D$da[1], ncol = MRA1$D$da[2])
grad_alpha_x1 <- (MRA1$dW * Wdiffsx * MRA1$W) %*% alpha_x1
grad_alpha_y1 <- (MRA1$dW * Wdiffsy * MRA1$W) %*% alpha_y1
dat <- tibble(d = seq(0, 2, length.out=100),
f = wendland_basis(d, radius = 2),
df = dwendland_basis(d, radius = 2))
ggplot(dat) +
geom_line(aes(x = d, y = f), color='red') +
geom_line(aes(x = d, y = df), color='blue')
mydist <- function(x, y) {
n <- length(x)
out <- rep(0, n)
for (i in 1:n) {
out[i] <- sqrt(sum((x[i] - y[i])^2))
}
out
}
ddistx <- function(x, y) {
2 * (x - y)
}
ddisty <- function(x, y) {
2 * (y - x)
}
ddist <- function(x, y) {
2 * c(x - y, y - x)
}
df <- expand_grid(x=seq(0, 1, length.out=20),
y=seq(0, 1, length.out=20)) %>%
rowwise() %>%
mutate(dist = mydist(x, y)) %>%
# rowwise() %>%
# mutate(ddist = ddist(x, y)) %>%
rowwise() %>%
mutate(ddistx = ddist(x, y)[1]) %>%
rowwise() %>%
mutate(ddisty = ddist(x, y)[2])
rowid <- c(19, 49, 149, 169, 249, 349, 389)
grad_plot <- df[rowid, ]
ggplot(df) +
geom_contour_filled(aes(x = x, y = y, z = dist)) +
geom_point(data = grad_plot, aes(x, y)) +
geom_segment(data=grad_plot, aes(x = x, y = y, xend = x - ddistx, yend = y - ddisty),
arrow = arrow(length = unit(0.1, "in")))
# chain rule - check direction for ddist and determine where the radius shows up (it is a constant so it should be ignorable-ish)
# dwendland * ddist * dvector-matrix
# d/dalpha = dwendland(W) * ddist(Walpha_x, W_alpha_y) * (W, W)
source("~/BayesMRA/R/wendland_basis.R")
wendland_basis(0.5, 1.5)
library(sgMRA)
wendland_basis(0.5, 1.5)
#'
#' @return The output of the Wendland basis applied to the distance `d` for a given radius `radius`.
#'
#' @examples
#' layout(matrix(1:2, 1, 2))
#' curve(wendland_basis(sqrt(x^2), radius = 1), from = -2, to = 2)
#' curve(wendland_basis(sqrt(x^2), radius = 2), from = -2, to = 2)
#'
#' @export
#'
wendland_basis <- function(d, radius) {
# if (any(is.na(d))) {
#     stop("d must not contain missing values")
# }
# if (any(d < 0)) {
#     stop("d must be nonnegative")
# }
# if (!is_positive_numeric(radius, 1)) {
#     stop("radius must be a single positive numeric value")
# }
d_rad <- d / radius
return(((1 - d_rad)^6 * (35 * d_rad^2 + 18 * d_rad + 3)) / 3 * (d_rad < 1))
}
wendland_basis(0.5, 1.5)
wendland_basis(.85, 1.5)
dwendland_basis <- function(d, radius) {
d_rad <- d / radius
1 / radius * (- 56 / 3 * d_rad * (5 * d_rad + 1) * (1 - d_rad)^5) * (d_rad < 1)
}
dwendland_basis(0.85, 1.5)
dwendland_basis(0.5, 1.5)
dwendland_basis(c(0, 0.5, 0.85, 4), 1.5)
wendland_basis(c(0, 0.5, 0.85, 4), 1.5)
dwendland_basis(0.4, 1.5)
curve(sin(x)/x)
