# exponential decay schedule
# rate_schedule <- exp(rep(seq(log(0.1), log(0.001), length = n_steps), each = ceiling(n_iter / n_steps)))
plot(rate_schedule)
message("Simulated loss:", 1 / (2 * N) * sum((y - z)^2))
# profvis::profvis({
# system.time({
out <- fit_sgd(y = y, locs = locs, grid = grid,
# learn_rate = 0.001,
rate_schedule=rate_schedule,
n_iter = n_iter,
n_message = 50,
penalized=FALSE,
plot_during_fit = TRUE,
noisy=TRUE)
# linear schedule
rate_schedule <- rep(seq(0.05, 0.001, length = n_steps), each = ceiling(n_iter / n_steps))
# exponential decay schedule
# rate_schedule <- exp(rep(seq(log(0.1), log(0.001), length = n_steps), each = ceiling(n_iter / n_steps)))
plot(rate_schedule)
message("Simulated loss:", 1 / (2 * N) * sum((y - z)^2))
# profvis::profvis({
# system.time({
out <- fit_sgd(y = y, locs = locs, grid = grid,
# learn_rate = 0.001,
rate_schedule=rate_schedule,
n_iter = n_iter,
n_message = 50,
penalized=FALSE,
plot_during_fit = TRUE,
noisy=TRUE)
# TODO
# - work on fitting these using stochastic gradient descent or elliptical slice sampling
# Deep BayesMRA
library(spam)
library(Matrix)
library(igraph)
library(tidyverse)
library(BayesMRA)
library(patchwork)
library(sgMRA)
# source("~/sgMRA/R/eval_basis.R")
# Rcpp::sourceCpp("~/sgMRA/src/dist_near_cpp.cpp")
# source("~/sgMRA/R/dwendland_basis.R")
set.seed(44)
N <- 2^12
locs <- expand_grid(x=seq(0, 1, length.out=sqrt(N)),
y=seq(0, 1, length.out=sqrt(N)))
idx1 <- ((locs$x > 1/4) & (locs$x <= 3/4)) & ((locs$y > 1/4) & (locs$y <= 3/4))
idx2 <- ((locs$x > 1/2) & (locs$x <= 3/4)) & ((locs$y > 1/2) & (locs$y <= 3/4))
idx3 <- ((locs$x > 1/4) & (locs$x <= 1/2)) & ((locs$y > 1/4) & (locs$y <= 1/2))
z <- cos(2*pi*locs$x) * cos(2*pi*locs$y)
z[idx1] <- z[idx1] + sin(4*pi*locs$x[idx1]) * sin(4*pi*locs$y[idx1])
z[idx2] <- z[idx2] + sin(8*pi*locs$x[idx2]) * sin(8*pi*locs$y[idx2])
z[idx3] <- z[idx3] + sin(16*pi*locs$x[idx3]) * sin(16*pi*locs$y[idx3])
z <- 2*z
M <- 1
n_coarse_grid <- 200
grid <- make_grid(locs, M = M, n_coarse_grid = n_coarse_grid)
MRA <- eval_basis(locs, grid, use_spam = FALSE)
dim(MRA$W)
sigma <- 0.05
epsilon <- rnorm(N, 0, sigma)
y_obs <- z + epsilon
y <- y_obs
dat <- data.frame(x = locs$x, y = locs$y, z = z, y_obs = y_obs)
p1 <- ggplot(dat, aes(x = x, y = y, fill = z)) +
geom_raster() +
# scale_fill_distiller(palette = "RdYlBu")
scale_fill_viridis_c()
p2 <- ggplot(dat, aes(x = x, y = y, fill = y_obs)) +
geom_raster() +
# scale_fill_distiller(palette = "RdYlBu")
scale_fill_viridis_c()
p1 + p2
# dat <- data.frame(x = locs$x, y = locs$y,
#                   # layer = rep(c(1, 1, 2, 2, 3), each=N),
#                   layer = rep(c(1, 1, 2), each=N),
#                   group = rep(c("x", "y", "z"), each = N),
#                   # group = rep(c("x", "y", "x", "y", "z"), each = N),
#                   z = c(W1 %*% alpha_x1, W1 %*% alpha_y1,
#                         # W2 %*% alpha_x2, W2 %*% alpha_y2,
#                         W %*% alpha))
# p_layers_sim <- ggplot(dat, aes(x, y, fill=z)) +
#     geom_raster() +
#     scale_fill_viridis_c() +
#     facet_grid(layer ~ group) +
#     ggtitle("simulated layers")
#
# p_layers_sim
# Fit the model using sgd ----
# source("~/sgMRA/scripts/fit-deep-MRA-sgd.R")
# source("~/sgMRA/R/adam.R")
n_iter = 5000
n_steps <- 50
# linear schedule
rate_schedule <- rep(seq(0.05, 0.001, length = n_steps), each = ceiling(n_iter / n_steps))
# plot(rate_schedule)
# exponential decay schedule
# rate_schedule <- exp(rep(seq(log(0.1), log(0.001), length = n_steps), each = ceiling(n_iter / n_steps)))
plot(rate_schedule)
message("Simulated loss:", 1 / (2 * N) * sum((y - z)^2))
# profvis::profvis({
# system.time({
out <- fit_sgd(y = y, locs = locs, grid = grid,
# learn_rate = 0.001,
rate_schedule=rate_schedule,
n_iter = n_iter,
n_message = 50,
penalized=TRUE,
plot_during_fit = TRUE,
noisy=TRUE)
library(sgMRA)
library(sgMRA)
library(purrr)
library(furrr)
# Deep BayesMRA
library(spam)
library(Matrix)
library(igraph)
library(tidyverse)
library(BayesMRA)
library(patchwork)
library(sgMRA)
set.seed(404)
N <- 2^14
M <- 3
n_coarse_grid <- 40
# N <- 2^12
# M <- 1
# n_coarse_grid <- 80
# source("~/sgMRA/R/sim-deep-mra.R")
dat_sim <- sim_deep_mra(N, M, n_coarse_grid, n_layers = 3, sigma = 0.1, use_spam = FALSE)
y=dat_sim$y
grid=dat_sim$grid
MRA=dat_sim$MRA[[1]]
MRA1=dat_sim$MRA[[2]]
MRA2=dat_sim$MRA[[3]]
W = MRA$W
W1 = MRA1$W
W2 = MRA2$W
dW = MRA$dW
dW1 = MRA1$dW
ddistx = MRA$ddistx
ddistx2 = MRA1$ddistx
ddisty = MRA$ddisty
ddisty2 = MRA1$ddisty
alpha=dat_sim$alpha
alpha_x1=dat_sim$alpha_x[[1]]
alpha_y1=dat_sim$alpha_y[[1]]
alpha_x2=dat_sim$alpha_x[[2]]
alpha_y2=dat_sim$alpha_y[[2]]
locs <- dat_sim$locs
z <- dat_sim$z
y_obs<- dat_sim$y
m=3
radius <- 1
parallel::detectCores()
calc_dist_par <- function(i, m, locs, grid) {
tmp=as.data.frame(t(distance_near_row_cpp(i=as.integer(i-1), locs = as.matrix(locs[i,]), locs_grid = as.matrix(grid$locs_grid[[m]]), radius=grid$radius[m])))
colnames(tmp) = c("I", "J", "V", "ddistx", "ddisty")
tmp
}
tst=calc_dist_par(2, 1, locs, grid)
# 20 secs
D <- vector(mode = 'list', length =  M)
# for (m in 1:M) {
system.time({
D[[m]] <- purrr::map_dfr(.x = 1:N, .f = ~ calc_dist_par(.x, m=m, locs=locs, grid=grid))
})
# 8.5 secs with 4 workers
D_par <- vector(mode = 'list', length =  M)
# for (m in 1:M) {
future::plan(multisession, workers = 4)
system.time({
D_par[[m]] <- furrr::future_map_dfr(.x = 1:N, .f = ~ calc_dist_par(.x, m=m, locs=locs, grid=grid),
.options = furrr_options(seed=NULL))
})
# 19 secs
system.time({
D2 <- distance_near_with_ddist_cpp(as.matrix(locs), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m])
})
# for (m in 1:M) {
# future::plan(multisession, workers = 4)
future::plan(multisession, workers = 6)
system.time({
D_par[[m]] <- furrr::future_map_dfr(.x = 1:N, .f = ~ calc_dist_par(.x, m=m, locs=locs, grid=grid),
.options = furrr_options(seed=NULL))
})
# for (m in 1:M) {
# future::plan(multisession, workers = 4)
# future::plan(multisession, workers = 6)
future::plan(multisession, workers = 8)
system.time({
D_par[[m]] <- furrr::future_map_dfr(.x = 1:N, .f = ~ calc_dist_par(.x, m=m, locs=locs, grid=grid),
.options = furrr_options(seed=NULL))
})
# for (m in 1:M) {
# future::plan(multisession, workers = 4)
future::plan(multisession, workers = 6)
# future::plan(multisession, workers = 8)
system.time({
D_par[[m]] <- furrr::future_map_dfr(.x = 1:N, .f = ~ calc_dist_par(.x, m=m, locs=locs, grid=grid),
.options = furrr_options(seed=NULL))
})
all.equal(as.matrix(D_par[[m]][, 1:2]), as.matrix(D2$ind), check.attributes=FALSE)
all.equal(as.matrix(D_par[[m]][, 3]), as.matrix(D2$V), check.attributes=FALSE)
all.equal(as.matrix(D_par[[m]][, 4]), as.matrix(D2$ddistx), check.attributes=FALSE)
all.equal(as.matrix(D_par[[m]][, 5]), as.matrix(D2$ddisty), check.attributes=FALSE)
#  17.5 sec 5xN as a matrix filled in a loop with byrow=TRUE
system.time({
D3 <- t(distance_near_loop_cpp(as.matrix(locs), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=TRUE))
})
# 17.5 sec 5xN as a matrix filled in a loop with byrow=FALSE
system.time({
D4 <- distance_near_loop_cpp(as.matrix(locs), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE)
})
# check equality
all.equal(D3, D4)
all.equal(D2$ind, D3[, 1:2])
all.equal(drop(D2$V), D3[, 3])
all.equal(drop(D2$ddistx), D3[, 4])
all.equal(drop(D2$ddisty), D3[, 5])
furrr:::make_chunks
furrr:::compute_n_chunks_from_scheduling
furrr:::compute_n_chunks_from_scheduling_integer
furrr:::compute_n_chunks_from_scheduling_logical()
furrr:::compute_n_chunks_from_scheduling_logical(
furrr:::compute_n_chunks_from_scheduling_logical
parallel::splitIndices
parallel::splitIndices
library(sgMRA)
D4 <- distance_near_loop_cpp(as.matrix(locs[1:20]), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE, num_threads=4)
D4 <- distance_near_chunk_cpp(as.matrix(locs[1:20]), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE, num_threads=4)
D4 <- distance_near_chunk_cpp(as.matrix(locs[1:20, ]), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE, num_threads=4)
library(sgMRA)
# building openmp chunks
D4 <- distance_near_chunk_cpp(as.matrix(locs[1:20, ]), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE, num_threads=4)
library(sgMRA)
# building openmp chunks
D4 <- distance_near_chunk_cpp(as.matrix(locs[1:20, ]), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE, num_threads=4)
# building openmp chunks
D4 <- distance_near_chunk_cpp(as.matrix(locs[1:21, ]), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE, num_threads=4)
library(sgMRA)
D4 <- distance_near_chunk_cpp(as.matrix(locs[1:21, ]), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE, num_threads=4)
library(sgMRA)
D4 <- distance_near_chunk_cpp(as.matrix(locs[1:21, ]), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE, num_threads=4)
D4 <- distance_near_chunk_cpp(as.matrix(locs[1:21, ]), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE, num_threads=4)
library(sgMRA)
D4 <- distance_near_chunk_cpp(as.matrix(locs[1:21, ]), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE, num_threads=4)
library(sgMRA)
D4 <- distance_near_chunk_cpp(as.matrix(locs[1:21, ]), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE, num_threads=4)
# building openmp chunks
D4 <- distance_near_chunk_cpp(as.matrix(locs[1:23, ]), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE, num_threads=4)
# building openmp chunks
D4 <- distance_near_chunk_cpp(as.matrix(locs[1:24, ]), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE, num_threads=4)
library(sgMRA)
D4 <- distance_near_chunk_cpp(as.matrix(locs[1:24, ]), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE, num_threads=4)
# building openmp chunks
D4 <- distance_near_chunk_cpp(as.matrix(locs[1:24, ]), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE, num_threads=7)
# building openmp chunks
D4 <- distance_near_chunk_cpp(as.matrix(locs[1:29, ]), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE, num_threads=7)
# building openmp chunks
D4 <- distance_near_chunk_cpp(as.matrix(locs[1:42, ]), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE, num_threads=7)
# building openmp chunks
D4 <- distance_near_chunk_cpp(as.matrix(locs), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE, num_threads=7)
16384*7
N
2.3410e+03*7
2.3410e+03*4 + 2.3400e+03*3
library(sgMRA)
library(sgMRA)
# building openmp chunks
D4 <- distance_near_chunk_cpp(as.matrix(locs), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE, num_threads=1)
D4 <- distance_near_chunk_cpp(as.matrix(locs), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE, num_threads=1)
D4 <- distance_near_chunk_cpp(as.matrix(locs), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE, num_threads=1)
library(sgMRA)
D4 <- distance_near_chunk_cpp(as.matrix(locs), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE, num_threads=1)
# building openmp chunks
D4 <- distance_near_chunk_cpp(as.matrix(locs), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE, ncores = =1)
# building openmp chunks
D4 <- distance_near_chunk_cpp(as.matrix(locs), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE, ncores =1)
library(sgMRA)
D4 <- distance_near_chunk_cpp(as.matrix(locs), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE, ncores =1)
diff
library(sgMRA)
D4 <- distance_near_chunk_cpp(as.matrix(locs), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE, ncores =1)
str(D4)
# building openmp chunks
system.time({
D4 <- distance_near_chunk_cpp(as.matrix(locs), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE, ncores =2)
})
D4 <- distance_near_chunk_cpp(as.matrix(locs), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE, ncores =1)
str(D4)
str(D4)
# building openmp chunks
# sec for ncore=1
system.time({
D5 <- distance_near_chunk_cpp(as.matrix(locs), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE, ncores =2)
})
# building openmp chunks
# sec for ncore=1
system.time({
D5 <- distance_near_chunk_cpp(as.matrix(locs), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE, ncores =1)
})
all.equal(D2$ind, D5[[1]][, 1:2])
all.equal(drop(D2$V), D5[[1]][, 3])
all.equal(drop(D2$ddistx), D5[[1]][, 4])
all.equal(drop(D2$ddisty), D5[[1]][, 5])
str(D4)
D5 <- distance_near_chunk_cpp(as.matrix(locs), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE, ncores =2)
str(D2)
str(D5)
library(sgMRA)
# building openmp chunks
# 17 sec for ncores=1
#  sec for ncores=2
#  sec for ncores=4
#  sec for ncores=6
system.time({
D5 <- distance_near_chunk_cpp(as.matrix(locs), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE, ncores =2)
})
str(D5)
str(D5)
all.equal(D2$ind, do.call(rbind, D5)[, 1:2])
all.equal(D2$ind, do.call(rbind, D5)[, 1:2])
all.equal(drop(D2$V), do.call(rbind, D5)[, 3])
all.equal(drop(D2$ddistx), do.call(rbind, D5)[, 4])
all.equal(drop(D2$ddisty), do.call(rbind, D5)[, 5])
# building openmp chunks
# 17 sec for ncores=1
#  17 sec for ncores=2 (running sequentially)
#  sec for ncores=4
#  sec for ncores=6
system.time({
D5 <- distance_near_chunk_cpp(as.matrix(locs), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE, ncores =4)
})
i
i
all.equal(D2$ind, do.call(rbind, D5)[, 1:2])
all.equal(drop(D2$V), do.call(rbind, D5)[, 3])
all.equal(drop(D2$ddistx), do.call(rbind, D5)[, 4])
all.equal(drop(D2$ddisty), do.call(rbind, D5)[, 5])
# building openmp chunks
# 17 sec for ncores=1
# 17 sec for ncores=2 (running sequentially)
# 17 sec for ncores=4 (running sequentially)
#  sec for ncores=5 (running sequentially)
#  sec for ncores=6 (running sequentially)
system.time({
D5 <- distance_near_chunk_cpp(as.matrix(locs), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE, ncores =5)
})
# when ncores = 1
all.equal(D2$ind, do.call(rbind, D5)[, 1:2])
all.equal(drop(D2$V), do.call(rbind, D5)[, 3])
all.equal(drop(D2$ddistx), do.call(rbind, D5)[, 4])
all.equal(drop(D2$ddisty), do.call(rbind, D5)[, 5])
D5 <- distance_near_chunk_cpp(as.matrix(locs), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE, ncores=6)
system.time({
D5 <- distance_near_chunk_cpp(as.matrix(locs), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE, ncores=6)
})
library(sgMRA)
system.time({
D5 <- distance_near_chunk_cpp(as.matrix(locs), as.matrix(grid$locs_grid[[m]]),
radius = grid$radius[m], byrow=FALSE, ncores=6)
})
sourceCpp(code = '
#include <unistd.h>
#include <Rcpp.h>
// [[Rcpp::plugins(openmp)]]
// [[Rcpp::export(wait_a_second_omp)]]
bool wait_a_second_omp(int sec, int ncores)
{
#if defined(_OPENMP)
#pragma omp parallel num_threads(ncores)
#pragma omp for
#endif
for(size_t ii = 0; ii < sec; ii++)
{
sleep(1);
}
return 1;
}
')
sourceCpp(code = '
#include <unistd.h>
#include <Rcpp.h>
// [[Rcpp::plugins(openmp)]]
// [[Rcpp::export(wait_a_second_omp)]]
bool wait_a_second_omp(int sec, int ncores)
{
#if defined(_OPENMP)
#pragma omp parallel num_threads(ncores)
#pragma omp for
#endif
for(size_t ii = 0; ii < sec; ii++)
{
sleep(1);
}
return 1;
}
')
Rcpp::sourceCpp(code = '
#include <unistd.h>
#include <Rcpp.h>
// [[Rcpp::plugins(openmp)]]
// [[Rcpp::export(wait_a_second_omp)]]
bool wait_a_second_omp(int sec, int ncores)
{
#if defined(_OPENMP)
#pragma omp parallel num_threads(ncores)
#pragma omp for
#endif
for(size_t ii = 0; ii < sec; ii++)
{
sleep(1);
}
return 1;
}
')
Rcpp::sourceCpp(code = '
#include <unistd.h>
#include <Rcpp.h>
// [[Rcpp::plugins(openmp)]]
// [[Rcpp::export(wait_a_second_omp)]]
bool wait_a_second_omp(int sec, int ncores)
{
#if defined(_OPENMP)
#pragma omp parallel num_threads(ncores)
#pragma omp for
#endif
for(size_t ii = 0; ii < sec; ii++)
{
sleep(1);
}
return 1;
}
')
Rcpp::sourceCpp(code = '
#include <unistd.h>
#include <Rcpp.h>
// [[Rcpp::plugins(openmp)]]
// [[Rcpp::export(wait_a_second_omp)]]
bool wait_a_second_omp(int sec, int ncores)
{
#if defined(_OPENMP)
#pragma omp parallel num_threads(ncores)
#pragma omp for
#endif
for(size_t ii = 0; ii < sec; ii++)
{
sleep(1);
}
return 1;
}
')
Rcpp::sourceCpp(code = '
#include <unistd.h>
#include <Rcpp.h>
// [[Rcpp::plugins(openmp)]]
// [[Rcpp::export(wait_a_second_omp)]]
bool wait_a_second_omp(int sec, int ncores)
{
#if defined(_OPENMP)
#pragma omp parallel num_threads(ncores)
#pragma omp for
#endif
for(size_t ii = 0; ii < sec; ii++)
{
sleep(1);
}
return 1;
}
')
